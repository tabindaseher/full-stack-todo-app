# Next.js App Router Frontend Development

This skill defines best practices and patterns for building Next.js applications using the App Router architecture.

## 1. App Router Structure

### Directory Structure
```
app/
├── layout.tsx          # Root layout
├── page.tsx           # Home page
├── globals.css        # Global styles
├── @modal/            # Slot for modal components
├── (group)/           # Route groups for organization
├── api/               # API routes
├── [slug]/            # Dynamic routes
└── [...catchall]/     # Catch-all routes
```

### Root Layout (app/layout.tsx)
```tsx
import './globals.css'

export const metadata = {
  title: 'My App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

## 2. Routing

### Static Routes
- Create directories for each route segment
- Use `page.tsx` to define route content
- Example: `app/about/page.tsx` → `/about`

### Dynamic Routes
- Use brackets `[param]` for dynamic segments
- Example: `app/users/[id]/page.tsx` → `/users/123`
- Access params via props: `{ params }: { params: { id: string } }`

### Catch-all Routes
- `[...slug]` for multiple segments: `/docs/a/b/c`
- `[[...slug]]` for optional catch-all: `/docs` or `/docs/a/b`

### Route Groups
- Use parentheses `(auth)` to organize routes without affecting URL structure
- Example: `(auth)/login/page.tsx` and `(auth)/register/page.tsx` both accessible at `/login` and `/register`

## 3. Server vs Client Components

### Server Components (Default)
- Render on the server
- Access backend resources (databases, file systems, APIs)
- Cannot use useState, useEffect, or event handlers
- More secure and efficient by default

```tsx
// app/users/page.tsx
async function UsersPage() {
  const users = await fetchUsers()

  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### Client Components
- Use `"use client"` directive at the top
- Run in the browser
- Can use React hooks and event handlers
- Imported into server components

```tsx
'use client'

import { useState } from 'react'

function Counter() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  )
}
```

### Best Practices
- Use server components by default
- Only use client components when you need interactivity
- Minimize client component size for better performance
- Pass data from server to client components as props

## 4. Data Fetching

### Server-Side Fetching
```tsx
// Server component
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    next: { revalidate: 60 } // Revalidate every 60 seconds
  })
  return res.json()
}

export default async function Page() {
  const data = await getData()
  return <div>{data.title}</div>
}
```

### Streaming
```tsx
// app/page.tsx
import { Suspense } from 'react'
import Albums from './albums'

export default function Page() {
  return (
    <div>
      <h1>My Music App</h1>
      <Suspense fallback={<div>Loading albums...</div>}>
        <Albums />
      </Suspense>
    </div>
  )
}
```

## 5. API Integration

### Server Actions (Recommended for mutations)
```tsx
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost(prevState: any, formData: FormData) {
  try {
    const title = formData.get('title')
    await db.post.create({ data: { title } })
    revalidatePath('/posts')
    return { success: true }
  } catch (error) {
    return { error: 'Failed to create post' }
  }
}
```

### Client-Side API Calls
```tsx
'use client'

import { useState } from 'react'

export default function PostForm() {
  const [title, setTitle] = useState('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    const response = await fetch('/api/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title })
    })
    if (response.ok) {
      setTitle('')
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button type="submit">Create Post</button>
    </form>
  )
}
```

### API Routes
```tsx
// app/api/posts/route.ts
import { NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const id = searchParams.get('id')

  return Response.json({ message: `Post ${id}` })
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  // Process the request
  return Response.json({ success: true })
}
```

## 6. Authentication Handling

### Middleware for Authentication
```ts
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'

export function middleware(request: NextRequest) {
  // Check for authentication token
  const token = request.cookies.get('auth-token')

  // Protected routes
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url))
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/dashboard/:path*', '/api/:path*']
}
```

### Session Provider
```tsx
// app/providers.tsx
'use client'

import { SessionProvider } from 'next-auth/react'

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      {children}
    </SessionProvider>
  )
}
```

### Protected Server Component
```tsx
// app/dashboard/page.tsx
import { auth } from '@/auth'

export default async function DashboardPage() {
  const session = await auth()

  if (!session) {
    return (
      <div>
        <p>Please log in to access the dashboard</p>
        <a href="/login">Log in</a>
      </div>
    )
  }

  return (
    <div>
      <h1>Welcome, {session.user?.name}</h1>
      {/* Dashboard content */}
    </div>
  )
}
```

### Protected Client Component
```tsx
'use client'

import { useSession } from 'next-auth/react'

export default function ProtectedComponent() {
  const { data: session, status } = useSession()

  if (status === 'loading') {
    return <div>Loading...</div>
  }

  if (!session) {
    return <div>Please log in</div>
  }

  return <div>Protected content</div>
}
```

## 7. Forms and Actions

### Server Action with Form
```tsx
// components/create-post.tsx
'use client'

import { useFormState, useFormStatus } from 'react-dom'
import { createPost } from '@/actions/posts'

function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Creating...' : 'Create Post'}
    </button>
  )
}

export default function CreatePostForm() {
  const [state, formAction] = useFormState(createPost, null)

  return (
    <form action={formAction}>
      <input name="title" placeholder="Title" required />
      <SubmitButton />
      {state?.error && <p>{state.error}</p>}
    </form>
  )
}
```

## 8. Error Handling

### Global Error Boundary
```tsx
// app/error.tsx
'use client'

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error
  reset: () => void
}) {
  useEffect(() => {
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

### Loading States
```tsx
// app/loading.tsx
export default function Loading() {
  return <div>Loading...</div>
}
```

## 9. SEO and Metadata

### Dynamic Metadata
```tsx
// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation'

export async function generateMetadata({
  params,
}: {
  params: { slug: string }
}) {
  const post = await getPost(params.slug)

  if (!post) {
    return {}
  }

  return {
    title: post.title,
    description: post.excerpt,
  }
}

export default async function PostPage({
  params,
}: {
  params: { slug: string }
}) {
  const post = await getPost(params.slug)

  if (!post) {
    notFound()
  }

  return <article>{post.content}</article>
}
```

## 10. Best Practices

- Use server components by default for better performance
- Leverage streaming for faster loading experiences
- Implement proper error boundaries
- Use metadata API for SEO
- Optimize images with next/image
- Use route handlers for API endpoints
- Implement proper caching strategies
- Follow security best practices (sanitize inputs, validate data)
- Use TypeScript for better type safety